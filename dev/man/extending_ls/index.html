<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extending LiveServer · LiveServer.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LiveServer.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../functionalities/">Functionalities</a></li><li class="current"><a class="toctext" href>Extending LiveServer</a><ul class="internal"><li><a class="toctext" href="#Using-SimpleWatcher-with-a-custom-callback-1">Using <code>SimpleWatcher</code> with a custom callback</a></li><li><a class="toctext" href="#Writing-your-own-FileWatcher-1">Writing your own <code>FileWatcher</code></a></li><li><a class="toctext" href="#Using-a-custom-coreloopfun-1">Using a custom <code>coreloopfun</code></a></li><li><a class="toctext" href="#Why-not-use-FileWatching?-1">Why not use <code>FileWatching</code>?</a></li></ul></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../../lib/public/">Public</a></li><li><a class="toctext" href="../../lib/internals/">Internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Extending LiveServer</a></li></ul><a class="edit-page" href="https://github.com/asprionj/LiveServer.jl/blob/master/docs/src/man/extending_ls.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Extending LiveServer</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Extending-LiveServer-1" href="#Extending-LiveServer-1">Extending LiveServer</a></h1><p>There may be circumstances where you will want the page-reloading to be triggered by your own mechanism. As a very simple example, you may want to display your own custom messages every time a file is updated. This page explains how to extend <code>SimpleWatcher &lt;: FileWatcher</code> and, more generally, how to write your own <code>FileWatcher</code>. We also explain how in some circumstances it may be easier to feed a custom <code>coreloopfun</code> to <a href="../../lib/public/#LiveServer.serve"><code>serve</code></a> rather than writing a custom callback.</p><h2><a class="nav-anchor" id="Using-SimpleWatcher-with-a-custom-callback-1" href="#Using-SimpleWatcher-with-a-custom-callback-1">Using <code>SimpleWatcher</code> with a custom callback</a></h2><p>In most circumstances, using an instance of the <code>SimpleWatcher</code> type with your own <em>custom callback function</em> is what you will want to do.</p><p>The <code>SimpleWatcher</code> does what you expect: it watches files for changes and triggers a function (the <em>callback</em>) when a change is detected. The callback function takes as argument the path of the file that was modified and returns <code>nothing</code>.</p><p>The base callback function (<a href="../../lib/internals/#LiveServer.file_changed_callback"><code>LiveServer.file_changed_callback</code></a>) does only one thing: it sends a signal to the relevant viewers to trigger page reloads. You will typically want to re-use <code>file_changed_callback</code> or copy its code.</p><p>As an example of a custom callback, here is a simple modified callback mechanism which prints <code>Hello!</code> before using the base callback function:</p><pre><code class="language-julia">custom_callback(fp::AbstractString) = (println(&quot;Hello!&quot;); file_changed_callback(fp))</code></pre><p>A more sophisticated customised callback is the one that is used in <a href="../../lib/public/#LiveServer.servedocs"><code>servedocs</code></a> (see <a href="../../lib/internals/#LiveServer.servedocs_callback"><code>LiveServer.servedocs_callback</code></a>). The callback has a different behaviour depending on which file is modified and does a few extra steps before signalling the viewers to reload appropriate pages.</p><h2><a class="nav-anchor" id="Writing-your-own-FileWatcher-1" href="#Writing-your-own-FileWatcher-1">Writing your own <code>FileWatcher</code></a></h2><p>If you decide to write your own <code>FileWatcher</code> type, you will need to meet the API. The easier is probably that you look at the code for <a href="../../lib/internals/#LiveServer.SimpleWatcher"><code>LiveServer.SimpleWatcher</code></a> and adapt it to your need. Let&#39;s assume for now that you want to define a <code>CustomWatcher &lt;: FileWatcher</code>.</p><h3><a class="nav-anchor" id="Fields-1" href="#Fields-1">Fields</a></h3><p>The only field that is <em>required</em> by the rest of the code is</p><ul><li><code>status</code>: a symbol that must be set to <code>:interrupted</code> upon errors in the file watching task</li></ul><p>Likely you will want to have some (probably most) of the fields of a <code>SimpleWatcher</code> i.e.:</p><ul><li><code>callback</code>: the callback function to be triggered upon an event,</li><li><code>task</code>: the asynchronous file watching task,</li><li><code>watchedfiles</code>: the vector of <a href="../../lib/internals/#LiveServer.WatchedFile"><code>LiveServer.WatchedFile</code></a> i.e. the paths to the file being watched as well as their time of last modification,</li><li><code>sleeptime</code>: the time to wait before going over the list of <code>watchedfiles</code> to check for changes, you won&#39;t want this to be too small and it&#39;s lower bounded to <code>0.05</code> in <code>SimpleWatcher</code>.</li></ul><p>Of course you can add any extra field you may want.</p><h3><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h3><p>Subsequently, your <code>CustomWatcher</code> may redefine some or all of the following methods (those that aren&#39;t will use the default method defined for <code>FileWatcher</code> and thus all of its sub-types).</p><p>The methods that are <em>required</em> by the rest of the code are</p><ul><li><code>start(::FileWatcher)</code> and <code>stop(::FileWatcher)</code> to start and stop the watcher,</li><li><code>watch_file!(::FileWatcher, ::AbstractString)</code> to consider an additional file.</li></ul><p>You may also want to re-define existing methods such as</p><ul><li><code>file_watcher_task!(::FileWatcher)</code>: the loop that goes over the watched files, checking for modifications and triggering the callback function. This task will be referenced by the field <code>CustomWatcher.task</code>. If errors happen in this asynchronous task, the <code>CustomWatcher.status</code> should be set to <code>:interrupted</code> so that all running tasks can be stopped properly.</li><li><code>set_callback!(::FileWatcher, ::Function)</code>: a helper function to bind a watcher with a callback function.</li><li><code>is_running(::FileWatcher)</code>: a helper function to check whether <code>CustomWatcher.task</code> is done.</li><li><code>is_watched(::FileWatcher, ::AbstractString)</code>: check if a file is watched by the watcher.</li></ul><h2><a class="nav-anchor" id="Using-a-custom-coreloopfun-1" href="#Using-a-custom-coreloopfun-1">Using a custom <code>coreloopfun</code></a></h2><p>In some circumstances, your code may be using specific data structures or be such that it wouldn&#39;t easily play well with a <code>FileWatcher</code> mechanism. In that case, you may want to also specify a <code>coreloopfun</code> which is called continuously in the <a href="../../lib/public/#LiveServer.serve"><code>serve</code></a> main function.</p><p>The code of <a href="../../lib/public/#LiveServer.serve"><code>serve</code></a> is essentially structured as follows:</p><pre><code class="language-julia">function serve(...)
    # ...
    @async HTTP.listen(...) # handles messages with the client (browser)
    # ...
    try
        counter = 1
        while true
            # ...
            coreloopfun(counter, filewatcher)
            counter += 1
            sleep(0.1)
        end
    catch err
        # ...
    finally
        # cleanup ...
    end
    return nothing
end</code></pre><p>And so the <code>coreloopfun</code> is called continuously while the server is running. By default the <code>coreloopfun</code> does nothing.</p><p>An example where using this could be relevant is if your code handles the processing of files from one format (say markdown) to HTML, that the FileWatcher would look at when the HTML files are produced but that you would want another process to keep track of the markdown files and process them as they should be. This is for instance what is used in <a href="https://github.com/tlienart/JuDoc.jl">JuDoc.jl</a>.</p><h2><a class="nav-anchor" id="Why-not-use-FileWatching?-1" href="#Why-not-use-FileWatching?-1">Why not use <code>FileWatching</code>?</a></h2><p>You may be aware of the <a href="https://docs.julialang.org/en/v1/stdlib/FileWatching/index.html"><code>FileWatching</code></a> module in <code>Base</code> and may wonder why we did not just use that one. The main reasons we decided not to use it are:</p><ul><li>it triggers <em>a lot</em>: where our system only triggers the callback function upon <em>saving</em> a file (e.g. you modified the file and saved the modification), <code>FileWatching</code> is more sensitive (for instance it will trigger when you <em>open</em> the file),</li><li>it is somewhat harder to make your own custom mechanisms to fire page reloads.</li></ul><p>So ultimately, our system can be seen as a poor man&#39;s implementation of <code>FileWatching</code> that is robust, simple and easy to customise.</p><footer><hr/><a class="previous" href="../functionalities/"><span class="direction">Previous</span><span class="title">Functionalities</span></a><a class="next" href="../../lib/public/"><span class="direction">Next</span><span class="title">Public</span></a></footer></article></body></html>
